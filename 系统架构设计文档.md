基于项目文档分析，我现在为您提供完整的系统架构设计文档。

---

# 学习记录管理项目 - 系统架构设计文档

> **文档版本**: v1.0
> **创建日期**: 2026-02-08
> **架构师**: System Architecture Team
> **关联文档**: [[记录学习过程项目]] | [[学习记录项目市场前景分析]]

---

## 一、系统整体架构

### 1.1 架构决策：单体应用 vs 微服务

### 最终决策：**模块化单体应用 + 微服务就绪设计**

#### 决策理由表

| 维度 | 微服务架构 | 模块化单体 | 最终选择 |
|------|-----------|-----------|---------|
| **开发效率** | 低（服务间通信复杂） | 高（直接调用） | 模块化单体 |
| **部署复杂度** | 高（容器编排） | 低（单一部署） | 模块化单体 |
| **运维成本** | 高（监控、链路追踪） | 低（统一日志） | 模块化单体 |
| **扩展性** | 高（独立扩展） | 中（整体扩展） | 微服务就绪 |
| **团队规模** | 适合20+人 | 适合5-15人 | 模块化单体 |
| **当前阶段** | 过度设计 | 适配MVP | 模块化单体 |

#### 架构演进路径

```
Phase 1 (0-10K用户)           Phase 2 (10K-100K用户)        Phase 3 (100K+用户)
┌─────────────────┐           ┌─────────────────┐           ┌─────────────────┐
│  模块化单体应用   │    →     │  模块化单体+缓存  │    →     │    微服务架构     │
│                 │           │  + CDN + 队列   │           │  + 服务网格      │
└─────────────────┘           └─────────────────┘           └─────────────────┘
```

### 1.2 系统架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              客户端层 (Client Layer)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ Web 应用     │  │ iOS App      │  │ Android App  │  │ 管理后台      │   │
│  │ (Next.js)    │  │ (React Native│  │ (React Native│  │ (Ant Design) │   │
│  │              │  │   / Flutter) │  │   / Flutter) │  │              │   │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘   │
└─────────┼─────────────────┼─────────────────┼─────────────────┼─────────────┘
          │                 │                 │                 │
          └─────────────────┼─────────────────┼─────────────────┘
                           │
                    ┌──────▼──────┐
                    │   CDN/WAF   │
                    │ 静态资源+防护 │
                    └──────┬──────┘
                           │
┌──────────────────────────▼──────────────────────────────────────────────────┐
│                           网关层 (Gateway Layer)                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │                    API Gateway (Kong/Traefik)                        │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐       │   │
│  │  │ 认证鉴权 │ │ 限流熔断 │ │ 路由转发 │ │ 日志审计 │ │ 监控指标 │       │   │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘       │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
└──────────────────────────┬──────────────────────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────────────────────┐
│                          应用层 (Application Layer)                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    主应用服务                         │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌───────────┐  │   │
│  │  │ 用户模块     │  │ 笔记模块     │  │ 脑图模块     │  │ 错题模块   │  │   │
│  │  │ - 认证授权   │  │ - CRUD      │  │ - AI生成    │  │ - CRUD     │  │   │
│  │  │ - 权限管理   │  │ - 分类管理   │  │ - 对比分析   │  │ - 薄弱点分析│  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └───────────┘  │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌───────────┐  │   │
│  │  │ AI服务模块   │  │ 协作模块     │  │ 分析模块     │  │ 通知模块   │  │   │
│  │  │ - LLM调用   │  │ - 分享合并   │  │ - 数据统计   │  │ - 提醒推送 │  │   │
│  │  │ - 向量检索   │  │ - 权限控制   │  │ - 可视化     │  │ - 消息队列 │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └───────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    AI工作器服务 (Python Worker)                      │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌───────────┐  │   │
│  │  │ OCR处理     │  │ 脑图生成     │  │ 向量嵌入     │  │ 知识点提问 │  │   │
│  │  │ - 百度OCR   │  │ - DeepSeek  │  │ - 语义分析   │  │ - 错题分析 │  │   │
│  │  │ - 腾讯OCR   │  │ - 通义千问   │  │ - 相似检索   │  │ - 复习推荐 │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └───────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└──────────────────────────┬──────────────────────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────────────────────┐
│                          服务层 (Service Layer)                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ 认证服务      │  │ 搜索服务      │  │ 文件服务      │  │ 实时服务      │   │
│  │ (JWT/OAuth)  │  │ (Elasticsearch│  │ (OSS/S3)     │  │ (WebSocket)  │   │
│  │              │  │  + pgvector)  │  │              │  │              │   │
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────────────────────┐
│                          数据层 (Data Layer)                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ PostgreSQL   │  │ Redis Cache  │  │ 向量数据库    │  │ 消息队列      │   │
│  │ (主数据+pgvec│  │ (会话/热点)   │  │ (ChromaDB/   │  │ (RabbitMQ/   │   │
│  │  tor扩展)    │  │              │  │  pgvector)   │  │  Redis)      │   │
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘   │
│                                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                       │
│  │ 对象存储      │  │ 时序数据库    │  │ 全文检索      │                       │
│  │ (阿里云OSS/  │  │ (学习记录)   │  │ (笔记内容)    │                       │
│  │  AWS S3)     │  │              │  │              │                       │
│  └──────────────┘  └──────────────┘  └──────────────┘                       │
└─────────────────────────────────────────────────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────────────────────┐
│                          外部服务 (External Services)                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ 百度OCR API  │  │ DeepSeek API │  │ 通义千问API   │  │ 支付服务      │   │
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、技术选型决策

### 2.1 后端技术栈决策

### 决策：**Node.js (NestJS) + Python FastAPI 混合架构**

#### 决策分析表

| 技术方案 | 优势 | 劣势 | 适用场景 |
|---------|------|------|---------|
| **Node.js/NestJS** | • TypeScript全栈<br>• 高并发处理<br>• 丰富生态<br>• JSON原生支持 | • AI库较少<br>• 计算密集型较弱 | Web服务、API网关、实时通信 |
| **Python/FastAPI** | • AI生态丰富<br>• 异步支持好<br>• 类型提示<br>• 数据处理强 | • 并发模型<br>• 部署相对复杂 | AI处理、OCR、向量计算 |
| **Go** | • 性能极佳<br>• 并发优秀 | • 学习曲线<br>• 生态较小 | 高并发场景 |
| **Java/Spring** | • 企业级成熟<br>• 生态完整 | • 启动慢<br>• 资源占用大 | 大型企业应用 |

#### 最终架构方案

```
┌─────────────────────────────────────────────────────────────────┐
│                      API 层              │
│                   (NestJS + TypeScript)                         │
│  • RESTful API                                                  │
│  • GraphQL (可选)                                               │
│  • WebSocket 实时通信                                           │
│  • JWT 认证授权                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ HTTP/gRPC
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                   AI 处理层                   │
│                   (FastAPI + Python)                             │
│  • OCR 文字识别                                                  │
│  • LLM 调用与流式输出                                            │
│  • 向量嵌入生成                                                  │
│  • 知识图谱构建                                                  │
└─────────────────────────────────────────────────────────────────┘
```

#### ADR-001: 后端技术栈选择

**Context**: 需要构建一个AI驱动的学习管理平台，包含Web服务和AI处理功能。

**Decision**: 
- **主服务**: Node.js + NestJS
- **AI服务**: Python + FastAPI
- **通信**: HTTP/REST (初期), gRPC (后期优化)

**Consequences**:

| 优点 | 缺点 |
|------|------|
| • 前后端语言统一(TS) | • 需要维护两套技术栈 |
| • NestJS企业级架构完善 | • 服务间通信增加延迟 |
| • Python AI生态丰富 | • 部署复杂度增加 |
| • 职责分离清晰 | • 开发团队需掌握两种语言 |

**Alternatives Considered**:
- **纯Node.js**: AI库支持不足，需要调用子进程
- **纯Python**: 异步并发处理不如Node.js成熟
- **Go + Python**: 前端集成复杂，开发效率低

**Status**: Accepted

### 2.2 前端技术栈决策

### 决策：**Next.js 15 + React 19 + Tailwind CSS**

#### 技术栈明细

```
┌─────────────────────────────────────────────────────────────────┐
│                          前端架构                                │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │  Web 应用        │  │  移动应用        │  │  管理后台        │ │
│  │  Next.js 15     │  │  React Native   │  │  Ant Design Pro │ │
│  │  React 19       │  │  Expo           │  │  Next.js 复用   │ │
│  │  TypeScript     │  │  TypeScript     │  │  TypeScript     │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
│                                                                  │
│  状态管理: Zustand / Jotai (轻量级)                              │
│  脑图可视化: D3.js / AntV X6                                    │
│  富文本编辑: Tiptap / ProseMirror                               │
│  数据可视化: ECharts / Recharts                                 │
│  样式方案: Tailwind CSS + CSS Modules                           │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 数据库技术选型

#### ADR-002: 数据库架构选择

**Decision**: **PostgreSQL (主库) + pgvector (向量扩展) + Redis (缓存)**

**架构图**:

```
┌─────────────────────────────────────────────────────────────────┐
│                         数据访问层                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────┐         ┌─────────────────┐               │
│  │   Repository    │         │   Cache Layer   │               │
│  │   Pattern       │◄────────┤   (Redis)        │               │
│  └────────┬────────┘         └─────────────────┘               │
│           │                                                       │
│           ▼                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   PostgreSQL 主库                        │   │
│  │  • 用户数据 (users, profiles)                           │   │
│  │  • 笔记数据 (notes, categories)                         │   │
│  │  • 错题数据 (mistakes, questions)                       │   │
│  │  • 协作数据 (shares, permissions)                       │   │
│  │  • 向量数据 (pgvector extension)                        │   │
│  │    - note_embeddings (1536维)                           │   │
│  │    - question_embeddings (1536维)                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌─────────────────┐         ┌─────────────────┐               │
│  │  对象存储        │         │  时序数据(可选)  │               │
│  │  (OSS/S3)       │         │  (InfluxDB)     │               │
│  │  • 文件/图片     │         │  • 学习记录      │               │
│  └─────────────────┘         └─────────────────┘               │
└─────────────────────────────────────────────────────────────────┘
```

**为什么不使用单独的向量数据库**:

| 方案 | 优势 | 劣势 | 适用场景 |
|------|------|------|---------|
| **pgvector** | • 统一数据管理<br>• 事务支持<br>• 运维简单 | • 性能略低<br>• 功能有限 | < 100万向量 |
| **ChromaDB** | • 专为向量优化<br>• 简单易用 | • 独立部署<br>• 数据同步 | 100万-1000万向量 |
| **Pinecone** | • 托管服务<br>• 性能最佳 | • 成本高<br>• 数据出境 | > 1000万向量 |

**演进路径**:
- **Phase 1**: PostgreSQL + pgvector (MVP)
- **Phase 2**: 添加 Redis 缓存热点向量
- **Phase 3**: 迁移至专业向量数据库

---

## 三、数据库设计

### 3.1 核心表结构

#### 用户与权限模块

```sql
-- 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    avatar_url VARCHAR(500),
    
    -- 用户状态
    status VARCHAR(20) DEFAULT 'active', -- active, suspended, deleted
    email_verified BOOLEAN DEFAULT false,
    
    -- 订阅信息
    subscription_tier VARCHAR(20) DEFAULT 'free', -- free, pro, team
    subscription_expires_at TIMESTAMP,
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    last_login_at TIMESTAMP,
    
    -- 索引
    CONSTRAINT email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_subscription ON users(subscription_tier, subscription_expires_at);

-- 用户配置表
CREATE TABLE user_settings (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    language VARCHAR(10) DEFAULT 'zh-CN',
    timezone VARCHAR(50) DEFAULT 'Asia/Shanghai',
    notification_enabled BOOLEAN DEFAULT true,
    review_reminder_enabled BOOLEAN DEFAULT true,
    review_reminder_time TIME DEFAULT '09:00',
    theme VARCHAR(20) DEFAULT 'light',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- OAuth绑定表 (支持第三方登录)
CREATE TABLE user_oauth_providers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider VARCHAR(50) NOT NULL, -- google, github, wechat
    provider_user_id VARCHAR(255) NOT NULL,
    access_token TEXT,
    refresh_token TEXT,
    expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(provider, provider_user_id)
);
```

#### 笔记管理模块

```sql
-- 笔记分类表 (支持层级结构)
CREATE TABLE categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    parent_id UUID REFERENCES categories(id) ON DELETE CASCADE,
    
    name VARCHAR(100) NOT NULL,
    description TEXT,
    color VARCHAR(7), -- HEX颜色
    icon VARCHAR(50),
    order_index INTEGER DEFAULT 0,
    
    -- 分类关系标签
    relation_type VARCHAR(20) DEFAULT 'independent', -- independent, related
    
    -- 元数据
    note_count INTEGER DEFAULT 0,
    total_mistakes INTEGER DEFAULT 0,
    mastery_level DECIMAL(3,2) DEFAULT 0, -- 0.00-1.00
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    CONSTRAINT valid_relation_type CHECK (relation_type IN ('independent', 'related'))
);

CREATE INDEX idx_categories_user ON categories(user_id, parent_id);
CREATE INDEX idx_categories_relation ON categories(user_id, relation_type);

-- 分类关系表 (多对多关联)
CREATE TABLE category_relations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    from_category_id UUID NOT NULL REFERENCES categories(id) ON DELETE CASCADE,
    to_category_id UUID NOT NULL REFERENCES categories(id) ON DELETE CASCADE,
    relation_strength DECIMAL(3,2) DEFAULT 0.5, -- 0.00-1.00 关联强度
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(from_category_id, to_category_id),
    CHECK (from_category_id != to_category_id)
);

-- 笔记表
CREATE TABLE notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    category_id UUID REFERENCES categories(id) ON DELETE SET NULL,
    
    title VARCHAR(200) NOT NULL,
    content TEXT, -- Markdown/HTML内容
    content_summary TEXT, -- AI生成的摘要
    
    -- 原始文件信息
    original_file_name VARCHAR(255),
    original_file_url VARCHAR(500), -- OSS/S3 URL
    original_file_type VARCHAR(50), -- image/pdf/handwriting
    
    -- AI处理状态
    ocr_status VARCHAR(20) DEFAULT 'pending', -- pending, processing, completed, failed
    ocr_text TEXT,
    mindmap_status VARCHAR(20) DEFAULT 'pending',
    mindmap_data JSONB, -- 存储生成的脑图结构
    embedding_status VARCHAR(20) DEFAULT 'pending',
    
    -- 元数据
    tags TEXT[], -- 标签数组
    is_public BOOLEAN DEFAULT false,
    view_count INTEGER DEFAULT 0,
    favorite_count INTEGER DEFAULT 0,
    
    -- 学习数据
    last_reviewed_at TIMESTAMP,
    review_count INTEGER DEFAULT 0,
    mastery_score DECIMAL(3,2) DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    CONSTRAINT valid_ocr_status CHECK (ocr_status IN ('pending', 'processing', 'completed', 'failed')),
    CONSTRAINT valid_mindmap_status CHECK (mindmap_status IN ('pending', 'processing', 'completed', 'failed'))
);

CREATE INDEX idx_notes_user ON notes(user_id, created_at DESC);
CREATE INDEX idx_notes_category ON notes(category_id);
CREATE INDEX idx_notes_tags ON notes USING GIN(tags);
CREATE INDEX idx_notes_public ON notes(is_public) WHERE is_public = true;
CREATE INDEX idx_notes_mastery ON notes(user_id, mastery_score);

-- 笔记附件表
CREATE TABLE note_attachments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
    
    file_name VARCHAR(255) NOT NULL,
    file_url VARCHAR(500) NOT NULL,
    file_type VARCHAR(50) NOT NULL,
    file_size INTEGER NOT NULL,
    mime_type VARCHAR(100),
    
    -- OCR相关
    ocr_processed BOOLEAN DEFAULT false,
    ocr_text TEXT,
    
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_note_attachments_note ON note_attachments(note_id);

-- 笔记分享表
CREATE TABLE note_shares (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
    shared_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    share_code VARCHAR(20) UNIQUE NOT NULL,
    share_type VARCHAR(20) DEFAULT 'link', -- link, user, group
    access_level VARCHAR(20) DEFAULT 'view', -- view, comment, edit
    
    -- 权限控制
    password_protected BOOLEAN DEFAULT false,
    password_hash VARCHAR(255),
    max_uses INTEGER,
    use_count INTEGER DEFAULT 0,
    expires_at TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP
);

CREATE INDEX idx_note_shares_code ON note_shares(share_code);
CREATE INDEX idx_note_shares_note ON note_shares(note_id);
```

#### 脑图模块

```sql
-- 脑图表
CREATE TABLE mindmaps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    note_id UUID REFERENCES notes(id) ON DELETE CASCADE, -- 可选，关联笔记
    
    name VARCHAR(200) NOT NULL,
    description TEXT,
    
    -- 脑图数据 (JSON格式存储树形结构)
    structure JSONB NOT NULL,
    /*
    结构示例:
    {
        "id": "root",
        "text": "中心主题",
        "children": [
            {
                "id": "node1",
                "text": "分支1",
                "children": [...]
            }
        ]
    }
    */
    
    -- 脑图类型
    map_type VARCHAR(20) DEFAULT 'user_generated', 
    -- user_generated, ai_generated, textbook_comparison
    
    -- AI生成信息
    ai_model VARCHAR(50),
    ai_generated_at TIMESTAMP,
    
    -- 对比分析 (当map_type=textbook_comparison时)
    compared_with_mindmap_id UUID REFERENCES mindmaps(id),
    comparison_result JSONB, /* 差异分析结果 */
    
    -- 元数据
    is_template BOOLEAN DEFAULT false,
    is_public BOOLEAN DEFAULT false,
    view_count INTEGER DEFAULT 0,
    fork_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_mindmaps_user ON mindmaps(user_id, created_at DESC);
CREATE INDEX idx_mindmaps_note ON mindmaps(note_id);
CREATE INDEX idx_mindmaps_type ON mindmaps(map_type);
CREATE INDEX idx_mindmaps_template ON mindmaps(is_template) WHERE is_template = true;

-- 脑图节点知识点关联表
CREATE TABLE mindmap_knowledge_points (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    mindmap_id UUID NOT NULL REFERENCES mindmaps(id) ON DELETE CASCADE,
    node_id VARCHAR(100) NOT NULL, -- 对应structure中的节点ID
    
    knowledge_text TEXT NOT NULL,
    embedding VECTOR(1536), -- pgvector存储
    
    -- 关联笔记内容
    related_note_id UUID REFERENCES notes(id),
    related_note_section VARCHAR(100), -- 笔记中的章节/段落标识
    
    -- 学习数据
    mastery_level DECIMAL(3,2) DEFAULT 0, -- 掌握程度
    question_count INTEGER DEFAULT 0, -- 相关题目数
    mistake_count INTEGER DEFAULT 0, -- 错题数
    
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(mindmap_id, node_id)
);

CREATE INDEX idx_mindmap_kp_mindmap ON mindmap_knowledge_points(mindmap_id);
CREATE INDEX idx_mindmap_kp_note ON mindmap_knowledge_points(related_note_id);
-- 向量相似度搜索索引
CREATE INDEX idx_mindmap_kp_embedding ON mindmap_knowledge_points 
    USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 100);
```

#### 错题管理模块

```sql
-- 错题表
CREATE TABLE mistakes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- 题目内容
    question_text TEXT NOT NULL,
    question_type VARCHAR(20) NOT NULL, -- choice, fill_blank, essay, calculation
    options JSONB, /* 选择题选项: ["A. xxx", "B. xxx", ...] */
    correct_answer TEXT NOT NULL,
    user_answer TEXT NOT NULL,
    
    -- 原始信息
    original_file_url VARCHAR(500), -- 手写/拍照上传的原始图片
    subject VARCHAR(50), -- 科目: 数学、英语、政治等
    difficulty INTEGER DEFAULT 3, -- 1-5 难度等级
    
    -- 知识点关联
    knowledge_points TEXT[], -- 关联的知识点标签
    related_mindmap_id UUID REFERENCES mindmaps(id),
    related_mindmap_node_id VARCHAR(100),
    related_note_id UUID REFERENCES notes(id),
    
    -- AI分析
    ai_analysis JSONB, /* AI生成的解析和建议 */
    weakness_score DECIMAL(3,2) DEFAULT 0.5, /* 薄弱程度 0-1 */
    
    -- 学习数据
    mistake_count INTEGER DEFAULT 1, -- 错误次数
    review_count INTEGER DEFAULT 0, -- 复习次数
    last_reviewed_at TIMESTAMP,
    next_review_at TIMESTAMP, -- 基于遗忘曲线的下次复习时间
    mastery_status VARCHAR(20) DEFAULT 'weak', -- weak, improving, mastered
    
    -- 元数据
    source VARCHAR(50), -- upload, auto_generated, shared
    is_public BOOLEAN DEFAULT false,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    CONSTRAINT valid_question_type CHECK (question_type IN ('choice', 'fill_blank', 'essay', 'calculation')),
    CONSTRAINT valid_mastery_status CHECK (mastery_status IN ('weak', 'improving', 'mastered'))
);

CREATE INDEX idx_mistakes_user ON mistakes(user_id, created_at DESC);
CREATE INDEX idx_mistakes_subject ON mistakes(user_id, subject);
CREATE INDEX idx_mistakes_knowledge ON mistakes USING GIN(knowledge_points);
CREATE INDEX idx_mistakes_next_review ON mistakes(next_review_at) WHERE next_review_at IS NOT NULL;
CREATE INDEX idx_mistakes_weakness ON mistakes(user_id, weakness_score DESC);

-- 错题知识点向量 (用于语义检索)
CREATE TABLE mistake_embeddings (
    mistake_id UUID PRIMARY KEY REFERENCES mistakes(id) ON DELETE CASCADE,
    question_embedding VECTOR(1536),
    analysis_embedding VECTOR(1536), /* AI解析的向量 */
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_mistake_embeddings_question ON mistake_embeddings 
    USING ivfflat (question_embedding vector_cosine_ops)
    WITH (lists = 100);

-- 错题本表 (用户可创建多个错题本分类)
CREATE TABLE mistake_notebooks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    name VARCHAR(100) NOT NULL,
    description TEXT,
    color VARCHAR(7),
    icon VARCHAR(50),
    order_index INTEGER DEFAULT 0,
    
    mistake_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 错题-错题本关联表
CREATE TABLE mistake_notebook_relations (
    mistake_id UUID NOT NULL REFERENCES mistakes(id) ON DELETE CASCADE,
    notebook_id UUID NOT NULL REFERENCES mistake_notebooks(id) ON DELETE CASCADE,
    added_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (mistake_id, notebook_id)
);
```

#### 知识点互动模块

```sql
-- 知识点提问记录表
CREATE TABLE knowledge_quiz_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    mindmap_id UUID NOT NULL REFERENCES mindmaps(id) ON DELETE CASCADE,
    
    session_type VARCHAR(20) DEFAULT 'practice', -- practice, exam, adaptive
    total_questions INTEGER DEFAULT 0,
    correct_count INTEGER DEFAULT 0,
    incorrect_count INTEGER DEFAULT 0,
    skipped_count INTEGER DEFAULT 0,
    
    -- 结果
    score DECIMAL(5,2),
    duration_seconds INTEGER,
    
    status VARCHAR(20) DEFAULT 'in_progress', -- in_progress, completed, abandoned
    started_at TIMESTAMP DEFAULT NOW(),
    completed_at TIMESTAMP,
    
    CONSTRAINT valid_session_status CHECK (status IN ('in_progress', 'completed', 'abandoned'))
);

CREATE INDEX idx_quiz_sessions_user ON knowledge_quiz_sessions(user_id, started_at DESC);
CREATE INDEX idx_quiz_sessions_mindmap ON knowledge_quiz_sessions(mindmap_id);

-- 知识点提问详情表
CREATE TABLE knowledge_quiz_questions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES knowledge_quiz_sessions(id) ON DELETE CASCADE,
    knowledge_point_id UUID NOT NULL REFERENCES mindmap_knowledge_points(id) ON DELETE CASCADE,
    
    question_text TEXT NOT NULL,
    question_type VARCHAR(20) NOT NULL, -- choice, fill_blank, open_ended
    options JSONB,
    correct_answer TEXT NOT NULL,
    
    user_answer TEXT,
    is_correct BOOLEAN,
    time_spent_seconds INTEGER,
    
    -- AI反馈
    ai_feedback JSONB, /* 解析和知识点定位 */
    related_note_section TEXT, /* 定位到笔记原文 */
    
    question_order INTEGER,
    answered_at TIMESTAMP,
    
    CONSTRAINT valid_q_question_type CHECK (question_type IN ('choice', 'fill_blank', 'open_ended'))
);

CREATE INDEX idx_quiz_questions_session ON knowledge_quiz_questions(session_id, question_order);
```

#### 协作学习模块

```sql
-- 笔记合并请求表
CREATE TABLE note_merge_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    requester_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    target_note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
    source_note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
    
    -- 合并策略
    merge_strategy VARCHAR(20) DEFAULT 'smart', -- append, smart, replace
    category_mapping JSONB, /* 源分类到目标分类的映射 */
    
    -- AI处理结果
    duplicate_removed INTEGER DEFAULT 0,
    sections_merged INTEGER DEFAULT 0,
    conflicts_resolved INTEGER DEFAULT 0,
    merge_result JSONB, /* 合并结果摘要 */
    
    status VARCHAR(20) DEFAULT 'pending', -- pending, processing, completed, failed
    error_message TEXT,
    
    created_at TIMESTAMP DEFAULT NOW(),
    completed_at TIMESTAMP
);

CREATE INDEX idx_note_merge_requests_user ON note_merge_requests(requester_id, created_at DESC);

-- 学习小组表
CREATE TABLE study_groups (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    creator_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    avatar_url VARCHAR(500),
    
    -- 设置
    is_public BOOLEAN DEFAULT false,
    max_members INTEGER DEFAULT 50,
    invite_code VARCHAR(20) UNIQUE,
    
    member_count INTEGER DEFAULT 0,
    note_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT NOW()
);

-- 小组成员表
CREATE TABLE study_group_members (
    group_id UUID NOT NULL REFERENCES study_groups(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(20) DEFAULT 'member', -- owner, admin, member
    joined_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (group_id, user_id),
    CONSTRAINT valid_role CHECK (role IN ('owner', 'admin', 'member'))
);

-- 小组笔记共享表
CREATE TABLE group_shared_notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    group_id UUID NOT NULL REFERENCES study_groups(id) ON DELETE CASCADE,
    note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
    shared_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    shared_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(group_id, note_id)
);
```

#### 学习数据分析模块

```sql
-- 学习活动记录表
CREATE TABLE study_activities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    activity_type VARCHAR(50) NOT NULL, 
    /* 
    Types: note_view, note_create, note_edit, mindmap_generate, 
    quiz_start, quiz_complete, mistake_add, mistake_review, 
    note_share, note_merge, group_join 
    */
    
    -- 关联资源
    resource_type VARCHAR(50), -- note, mindmap, mistake, quiz
    resource_id UUID,
    
    -- 活动数据
    duration_seconds INTEGER,
    metadata JSONB,
    
    ip_address INET,
    user_agent TEXT,
    
    created_at TIMESTAMP DEFAULT NOW()
);

-- 活动索引 (用于高效查询)
CREATE INDEX idx_study_activities_user_time ON study_activities(user_id, created_at DESC);
CREATE INDEX idx_study_activities_type ON study_activities(activity_type, created_at DESC);
-- 时效性索引 (30天自动分区)
CREATE INDEX idx_study_activities_recent ON study_activities(created_at DESC) 
    WHERE created_at > NOW() - INTERVAL '30 days';

-- 学习统计汇总表 (定期计算)
CREATE TABLE study_statistics (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    
    -- 时间维度统计
    today_study_minutes INTEGER DEFAULT 0,
    week_study_minutes INTEGER DEFAULT 0,
    month_study_minutes INTEGER DEFAULT 0,
    total_study_minutes INTEGER DEFAULT 0,
    
    -- 内容统计
    total_notes INTEGER DEFAULT 0,
    total_mindmaps INTEGER DEFAULT 0,
    total_mistakes INTEGER DEFAULT 0,
    total_quizzes INTEGER DEFAULT 0,
    
    -- 掌握度统计
    avg_mastery_score DECIMAL(5,2),
    mastered_points INTEGER DEFAULT 0,
    weak_points INTEGER DEFAULT 0,
    
    -- 活跃度
    consecutive_days INTEGER DEFAULT 0, -- 连续学习天数
    last_study_date DATE,
    
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 学习目标表
CREATE TABLE study_goals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    goal_type VARCHAR(50) NOT NULL, -- daily_minutes, weekly_notes, monthly_mistakes
    target_value INTEGER NOT NULL,
    current_value INTEGER DEFAULT 0,
    
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    
    status VARCHAR(20) DEFAULT 'active', -- active, completed, failed
    completed_at TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT NOW()
);
```

### 3.2 索引策略

#### 索引设计原则

```sql
-- 1. B-Tree 索引 (默认，等值/范围查询)
CREATE INDEX idx_notes_user_created ON notes(user_id, created_at DESC);

-- 2. GIN 索引 (数组/JSONB查询)
CREATE INDEX idx_notes_tags ON notes USING GIN(tags);
CREATE INDEX idx_notes_content ON notes USING GIN(to_tsvector('chinese', content));

-- 3. 部分索引 (带条件，节省空间)
CREATE INDEX idx_notes_public ON notes(id, user_id) WHERE is_public = true;

-- 4. 表达式索引 (函数结果)
CREATE INDEX idx_users_email_lower ON users(LOWER(email));

-- 5. 覆盖索引 (INCLUDE子句)
CREATE INDEX idx_mistakes_review ON mistakes(user_id, next_review_at) 
    INCLUDE (question_text, weakness_score);

-- 6. 向量索引
CREATE INDEX idx_kp_embedding ON mindmap_knowledge_points 
    USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 100);
```

### 3.3 数据分区策略

```sql
-- 学习活动表按月分区
CREATE TABLE study_activities (
    -- ... 字段定义
) PARTITION BY RANGE (created_at);

-- 创建分区
CREATE TABLE study_activities_2026_02 PARTITION OF study_activities
    FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');

CREATE TABLE study_activities_2026_03 PARTITION OF study_activities
    FOR VALUES FROM ('2026-03-01') TO ('2026-04-01');

-- 自动分区函数
CREATE OR REPLACE FUNCTION create_monthly_partition()
RETURNS void AS $$
DECLARE
    partition_date DATE := date_trunc('month', NOW() + INTERVAL '1 month');
    start_date TEXT := partition_date::TEXT;
    end_date TEXT := (partition_date + INTERVAL '1 month')::TEXT;
    partition_name TEXT := 'study_activities_' || to_char(partition_date, 'YYYY_MM');
BEGIN
    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I PARTITION OF study_activities 
         FOR VALUES FROM (%L) TO (%L)',
        partition_name, start_date, end_date
    );
END;
$$ LANGUAGE plpgsql;
```

---

## 四、AI服务架构

### 4.1 AI服务总体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           AI 服务架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        API 层                   │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │   │
│  │  │ OCR API     │  │ 脑图生成API  │  │ 向量检索API  │  │ 问答分析API  │  │   │
│  │  │ /ocr/*      │  │ /mindmap/*  │  │ /search/*   │  │ /quiz/*     │  │   │
│  │  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  │   │
│  └─────────┼─────────────────┼─────────────────┼─────────────────┼─────────┘   │
│            │                 │                 │                 │               │
│  ┌─────────▼─────────────────▼─────────────────▼─────────────────▼─────────┐ │
│  │                      服务编排层                       │ │
│  │  • 任务队列管理 • 优先级调度 • 重试机制 • 超时控制                      │ │
│  └──────────────────────────────────────────────────────────────────────┘ │
│            │                 │                 │                 │               │
│  ┌─────────▼─────────────────▼─────────────────▼─────────────────▼─────────┐ │
│  │                      处理器层                        │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │ │
│  │  │ OCR处理器   │  │ LLM处理器   │  │ 向量处理器   │  │ 分析处理器   │    │ │
│  │  │ - 百度OCR   │  │ - DeepSeek  │  │ - 嵌入生成  │  │ - 知识图谱   │    │ │
│  │  │ - 腾讯OCR   │  │ - 通义千问   │  │ - 相似检索  │  │ - 薄弱点分析  │    │ │
│  │  │ - Tesseract │  │ - 流式输出   │  │ - 聚类分析  │  │ - 学习建议   │    │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘    │ │
│  └──────────────────────────────────────────────────────────────────────┘ │
│            │                 │                 │                 │               │
│  ┌─────────▼─────────────────▼─────────────────▼─────────────────▼─────────┐ │
│  │                      外部API层                                          │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │ │
│  │  │ 百度AI      │  │ DeepSeek    │  │ 通义千问    │  │ HuggingFace │    │ │
│  │  │ 开放平台    │  │ API         │  │ API         │  │ (备用)      │    │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘    │ │
│  └──────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      缓存层                                    │   │
│  │  • 响应缓存 • 向量缓存 • 限流控制 • 成本追踪                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 AI服务实现

#### FastAPI 服务结构

```
ai-service/
├── app/
│   ├── __init__.py
│   ├── main.py                    # FastAPI 应用入口
│   ├── config.py                  # 配置管理
│   ├── api/
│   │   ├── __init__.py
│   │   ├── ocr.py                 # OCR API 路由
│   │   ├── mindmap.py             # 脑图生成 API
│   │   ├── embedding.py           # 向量嵌入 API
│   │   ├── quiz.py                # 知识点提问 API
│   │   └── analysis.py            # 分析服务 API
│   ├── services/
│   │   ├── __init__.py
│   │   ├── ocr_service.py         # OCR 处理服务
│   │   ├── llm_service.py         # LLM 调用服务
│   │   ├── embedding_service.py   # 向量嵌入服务
│   │   ├── mindmap_service.py     # 脑图生成服务
│   │   └── cache_service.py       # 缓存服务
│   ├── models/
│   │   ├── __init__.py
│   │   ├── requests.py            # 请求模型
│   │   └── responses.py           # 响应模型
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── prompt_templates.py    # Prompt 模板
│   │   ├── retry.py               # 重试装饰器
│   │   └── cost_tracker.py        # 成本追踪
│   └── middleware/
│       ├── __init__.py
│       └── rate_limit.py          # 限流中间件
├── tests/
├── requirements.txt
└── Dockerfile
```

#### OCR 服务实现示例

```python
# app/services/ocr_service.py
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any
import httpx
from tenacity import retry, stop_after_attempt, wait_exponential

class OCRProvider(ABC):
    """OCR提供者抽象基类"""
    
    @abstractmethod
    async def recognize(self, image_url: str) -> Dict[str, Any]:
        pass

class BaiduOCR(OCRProvider):
    """百度OCR实现"""
    
    def __init__(self, api_key: str, secret_key: str):
        self.api_key = api_key
        self.secret_key = secret_key
        self.access_token: Optional[str] = None
        self.base_url = "https://aip.baidubce.com/rest/2.0/ocr/v1"
    
    async def _get_access_token(self) -> str:
        """获取百度API access_token"""
        if self.access_token:
            return self.access_token
            
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "https://aip.baidubce.com/oauth/2.0/token",
                params={
                    "grant_type": "client_credentials",
                    "client_id": self.api_key,
                    "client_secret": self.secret_key
                }
            )
            self.access_token = response.json()["access_token"]
            return self.access_token
    
    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))
    async def recognize(self, image_url: str) -> Dict[str, Any]:
        """识别图片文字"""
        token = await self._get_access_token()
        
        async with httpx.AsyncClient() as client:
            # 下载图片
            img_response = await client.get(image_url)
            image_data = img_response.content
            
            # 调用OCR API
            response = await client.post(
                f"{self.base_url}/accurate_basic",
                params={"access_token": token},
                data={"image": base64.b64encode(image_data).decode()}
            )
            
            result = response.json()
            
            return {
                "text": "\n".join([item["words"] for item in result.get("words_result", [])]),
                "confidence": result.get("words_result", [{}])[0].get("probability", {}).get("average", 0),
                "provider": "baidu"
            }

class TencentOCR(OCRProvider):
    """腾讯OCR实现 (备用)"""
    # ... 类似实现

class OCRService:
    """OCR服务门面，支持多提供者切换"""
    
    def __init__(self, providers: Dict[str, OCRProvider], default: str = "baidu"):
        self.providers = providers
        self.default = default
    
    async def recognize(
        self, 
        image_url: str, 
        provider: Optional[str] = None,
        use_cache: bool = True
    ) -> Dict[str, Any]:
        """识别图片文字，支持缓存"""
        provider_name = provider or self.default
        
        # 检查缓存
        if use_cache:
            cached = await self._get_from_cache(image_url)
            if cached:
                return cached
        
        # 调用OCR
        ocr_provider = self.providers.get(provider_name)
        if not ocr_provider:
            raise ValueError(f"Unknown OCR provider: {provider_name}")
            
        result = await ocr_provider.recognize(image_url)
        
        # 缓存结果
        if use_cache:
            await self._save_to_cache(image_url, result)
        
        return result
    
    async def _get_from_cache(self, image_url: str) -> Optional[Dict[str, Any]]:
        # Redis缓存实现
        pass
    
    async def _save_to_cache(self, image_url: str, result: Dict[str, Any]):
        # Redis缓存实现
        pass
```

#### LLM 服务实现示例

```python
# app/services/llm_service.py
from typing import AsyncIterator, Optional, Dict, Any, List
import httpx
from tenacity import retry, stop_after_attempt, wait_exponential
import json

class LLMProvider(ABC):
    """大模型提供者抽象基类"""
    
    @abstractmethod
    async def chat_completion(
        self,
        messages: List[Dict[str, str]],
        stream: bool = False,
        **kwargs
    ) -> AsyncIterator[str] | str:
        pass

class DeepSeekProvider(LLMProvider):
    """DeepSeek API 实现"""
    
    def __init__(self, api_key: str, base_url: str = "https://api.deepseek.com/v1"):
        self.api_key = api_key
        self.base_url = base_url
        self.model = "deepseek-chat"
    
    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))
    async def chat_completion(
        self,
        messages: List[Dict[str, str]],
        stream: bool = False,
        temperature: float = 0.7,
        max_tokens: int = 2000,
        **kwargs
    ) -> AsyncIterator[str] | str:
        """调用DeepSeek聊天API"""
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": self.model,
            "messages": messages,
            "temperature": temperature,
            "max_tokens": max_tokens,
            "stream": stream
        }
        
        if stream:
            return self._stream_chat(headers, payload)
        else:
            return await self._complete_chat(headers, payload)
    
    async def _complete_chat(self, headers: dict, payload: dict) -> str:
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(
                f"{self.base_url}/chat/completions",
                headers=headers,
                json=payload
            )
            response.raise_for_status()
            result = response.json()
            return result["choices"][0]["message"]["content"]
    
    async def _stream_chat(self, headers: dict, payload: dict) -> AsyncIterator[str]:
        async with httpx.AsyncClient(timeout=120.0) as client:
            async with client.stream(
                "POST",
                f"{self.base_url}/chat/completions",
                headers=headers,
                json=payload
            ) as response:
                response.raise_for_status()
                async for line in response.aiter_lines():
                    if line.startswith("data: [DONE]"):
                        break
                    if line.startswith("data: "):
                        try:
                            data = json.loads(line[6:])
                            content = data["choices"][0]["delta"].get("content", "")
                            if content:
                                yield content
                        except json.JSONDecodeError:
                            continue

class LLMService:
    """LLM服务门面"""
    
    def __init__(self, default_provider: LLMProvider):
        self.default_provider = default_provider
        self.cost_tracker = CostTracker()
    
    async def generate_mindmap(
        self,
        note_content: str,
        title: str,
        max_nodes: int = 50
    ) -> Dict[str, Any]:
        """根据笔记内容生成脑图"""
        
        prompt = f"""请根据以下笔记内容，生成一个结构化的思维导图。

笔记标题: {title}
笔记内容:
{note_content}

要求:
1. 提取核心主题作为根节点
2. 提取3-5个主要分支
3. 每个分支提取3-5个子节点
4. 最多生成{max_nodes}个节点
5. 返回JSON格式，包含id, text, children字段

返回格式:
{{
    "id": "root",
    "text": "中心主题",
    "children": [
        {{
            "id": "node1",
            "text": "分支1",
            "children": [...]
        }}
    ]
}}"""

        messages = [
            {"role": "system", "content": "你是一个专业的思维导图生成助手，擅长提取知识结构。"},
            {"role": "user", "content": prompt}
        ]
        
        response = await self.default_provider.chat_completion(
            messages=messages,
            temperature=0.3,
            max_tokens=3000
        )
        
        # 解析JSON响应
        try:
            mindmap = json.loads(response)
            return mindmap
        except json.JSONDecodeError:
            # 如果返回的不是纯JSON，尝试提取
            import re
            json_match = re.search(r'\{[\s\S]*\}', response)
            if json_match:
                return json.loads(json_match.group())
            raise ValueError("Invalid mindmap response")
    
    async def compare_mindmaps(
        self,
        user_mindmap: Dict[str, Any],
        reference_mindmap: Dict[str, Any]
    ) -> Dict[str, Any]:
        """对比用户脑图与参考脑图"""
        
        prompt = f"""请对比以下两个思维导图，分析用户的知识掌握情况。

用户脑图:
{json.dumps(user_mindmap, ensure_ascii=False, indent=2)}

参考脑图:
{json.dumps(reference_mindmap, ensure_ascii=False, indent=2)}

请返回JSON格式的分析结果:
{{
    "missing_nodes": [{{"id": "xxx", "text": "遗漏的知识点", "importance": "high"}}],
    "weak_areas": [{{"topic": "xxx", "description": "薄弱领域描述"}}],
    "suggestions": ["建议1", "建议2"],
    "overall_score": 0.75
}}"""

        messages = [
            {"role": "system", "content": "你是一个专业的学习分析助手。"},
            {"role": "user", "content": prompt}
        ]
        
        response = await self.default_provider.chat_completion(
            messages=messages,
            temperature=0.3
        )
        
        try:
            return json.loads(response)
        except json.JSONDecodeError:
            # Fallback
            return {
                "missing_nodes": [],
                "weak_areas": [],
                "suggestions": ["无法解析分析结果"],
                "overall_score": 0.5
            }

class CostTracker:
    """API调用成本追踪"""
    
    def __init__(self):
        self.costs: Dict[str, float] = {}
    
    def record(self, provider: str, model: str, tokens: int, cost_per_1k: float):
        key = f"{provider}:{model}"
        self.costs[key] = self.costs.get(key, 0) + (tokens / 1000) * cost_per_1k
    
    def get_total_cost(self) -> float:
        return sum(self.costs.values())
```

### 4.3 AI成本优化策略

#### ADR-003: AI成本控制策略

**Context**: LLM API调用成本是项目主要运营成本，需要有效控制。

**Decision**: 多层缓存 + 模型分级 + 使用配额

**策略说明**:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          AI成本控制策略                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. 缓存策略 (优先级从高到低)                                                │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐                  │
│  │ 完全相同请求   │ → │ L1: Redis    │    │ 命中率: 30%   │                  │
│  │ (相同hash)   │    │ (TTL: 24h)   │    │ 成本节省: 30%  │                  │
│  └──────────────┘    └──────────────┘    └──────────────┘                  │
│                                                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐                  │
│  │ 语义相似请求   │ → │ L2: 向量检索  │    │ 命中率: 15%   │                  │
│  │ (相似度>0.9) │    │ (pgvector)   │    │ 成本节省: 15%  │                  │
│  └──────────────┘    └──────────────┘    └──────────────┘                  │
│                                                                              │
│  2. 模型分级策略                                                             │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐                  │
│  │  用户等级    │  基础模型    │  高级模型    │  成本/1K tokens│              │
│  ├─────────────┼─────────────┼─────────────┼─────────────┤                  │
│  │  免费用户    │  DeepSeek V3 │  -          │  ¥0.14      │                  │
│  │  Pro用户     │  DeepSeek V3 │  GPT-4o     │  ¥0.14/¥0.15│                │
│  │  团队用户     │  通义千问Plus│  GPT-4o     │  ¥0.20/¥0.15│                │
│  └─────────────┴─────────────┴─────────────┴─────────────┘                  │
│                                                                              │
│  3. 使用配额策略                                                             │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐                  │
│  │  用户等级    │  日配额      │  月配额      │  超额处理    │                  │
│  ├─────────────┼─────────────┼─────────────┼─────────────┤                  │
│  │  免费用户    │  100次/天   │  1000次/月  │  限流        │                  │
│  │  Pro用户     │  500次/天   │  10000次/月 │  按量计费    │                  │
│  │  团队用户     │  2000次/天  │  50000次/月 │  包含        │                  │
│  └─────────────┴─────────────┴─────────────┴─────────────┘                  │
│                                                                              │
│  4. Prompt优化策略                                                           │
│  • 使用结构化输出 (减少重试)                                                  │
│  • 批量处理 (减少请求次数)                                                    │
│  • Token计数提示 (控制输出长度)                                               │
│  • Few-shot示例 (提高准确率)                                                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**实现代码**:

```python
# app/utils/cost_tracker.py
from typing import Optional, Dict, Any
from datetime import datetime, timedelta
import hashlib
import json

class AICacheManager:
    """AI响应缓存管理器"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.vector_db = None  # 向量数据库连接
    
    def _make_cache_key(self, provider: str, model: str, messages: list) -> str:
        """生成缓存key"""
        content = json.dumps(messages, sort_keys=True, ensure_ascii=False)
        content_hash = hashlib.sha256(content.encode()).hexdigest()[:16]
        return f"ai:cache:{provider}:{model}:{content_hash}"
    
    async def get(self, provider: str, model: str, messages: list) -> Optional[str]:
        """获取缓存"""
        key = self._make_cache_key(provider, model, messages)
        cached = await self.redis.get(key)
        return cached.decode() if cached else None
    
    async def set(self, provider: str, model: str, messages: list, response: str, ttl: int = 86400):
        """设置缓存"""
        key = self._make_cache_key(provider, model, messages)
        await self.redis.setex(key, ttl, response)
    
    async def find_similar(
        self, 
        messages: list, 
        threshold: float = 0.9
    ) -> Optional[str]:
        """查找语义相似的缓存响应"""
        # 使用向量检索找相似请求
        embedding = await self._get_embedding(messages[-1]["content"])
        
        # pgvector 查询
        query = """
            SELECT request_messages, response_text, 
                   1 - (embedding <=> $1) as similarity
            FROM ai_cache_embeddings
            WHERE embedding <=> $1 < 0.1  -- 余弦距离阈值
            ORDER BY embedding <=> $1
            LIMIT 1
        """
        # 执行查询...
        return None if not result else result["response_text"]

class AIQuotaManager:
    """AI使用配额管理"""
    
    QUOTA_CONFIG = {
        "free": {"daily": 100, "monthly": 1000},
        "pro": {"daily": 500, "monthly": 10000},
        "team": {"daily": 2000, "monthly": 50000}
    }
    
    def __init__(self, redis_client):
        self.redis = redis_client
    
    async def check_quota(
        self, 
        user_id: str, 
        user_tier: str,
        increment: int = 1
    ) -> tuple[bool, Dict[str, Any]]:
        """检查用户配额"""
        today = datetime.now().strftime("%Y-%m-%d")
        month = datetime.now().strftime("%Y-%m")
        
        daily_key = f"quota:daily:{user_id}:{today}"
        monthly_key = f"quota:monthly:{user_id}:{month}"
        
        daily_count = await self.redis.incrby(daily_key, increment)
        monthly_count = await self.redis.incrby(monthly_key, increment)
        
        # 设置过期时间
        if daily_count == increment:
            await self.redis.expire(daily_key, 86400)
        if monthly_count == increment:
            await self.redis.expire(monthly_key, 2592000)  # 30天
        
        limits = self.QUOTA_CONFIG.get(user_tier, self.QUOTA_CONFIG["free"])
        
        can_proceed = (
            daily_count <= limits["daily"] and 
            monthly_count <= limits["monthly"]
        )
        
        return can_proceed, {
            "daily_used": daily_count,
            "daily_limit": limits["daily"],
            "monthly_used": monthly_count,
            "monthly_limit": limits["monthly"],
            "can_proceed": can_proceed
        }
```

---

## 五、文件存储方案

### 5.1 存储架构设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          文件存储架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        应用层                                       │   │
│  │  • 文件上传 • 格式验证 • 病毒扫描 • 权限检查                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌────────────────────────────────▼─────────────────────────────────────┐   │
│  │                        存储网关层                                     │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │   │
│  │  │ 上传策略     │  │ 访问控制     │  │ CDN分发     │  │ 缩略图生成   │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌────────────────────────────────▼─────────────────────────────────────┐   │
│  │                        对象存储层                                     │   │
│  │  ┌────────────────────────────────────────────────────────────────┐  │   │
│  │  │                   OSS/S3 Bucket 分层存储                         │  │   │
│  │  │                                                                  │  │   │
│  │  │  notes/{user_id}/{year}/{month}/{note_id}/                      │  │   │
│  │  │    ├── original/          原始上传文件                            │  │   │
│  │  │    ├── processed/         OCR处理后                              │  │   │
│  │  │    └── thumbnails/        缩略图                                  │  │   │
│  │  │                                                                  │  │   │
│  │  │  mistakes/{user_id}/{year}/{month}/{mistake_id}/                 │  │   │
│  │  │  avatars/{user_id}.{ext}                                         │  │   │
│  │  │  attachments/{note_id}/{attachment_id}.{ext}                     │  │   │
│  │  └────────────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌────────────────────────────────▼─────────────────────────────────────┐   │
│  │                        CDN加速层                                      │   │
│  │  • 静态资源分发 • 图片优化 • 视频加速 • 海外节点                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 文件上传服务实现

```typescript
// services/fileStorage.service.ts
import { v4 as uuidv4 } from 'uuid';
import * as OSS from 'ali-oss';
import sharp from 'sharp';

export interface UploadOptions {
  userId: string;
  fileType: 'note' | 'mistake' | 'avatar' | 'attachment';
  maxSize?: number; // bytes
  allowedMimes?: string[];
  generateThumbnail?: boolean;
}

export interface UploadResult {
  key: string;
  url: string;
  thumbnailUrl?: string;
  size: number;
  mimeType: string;
  etag?: string;
}

export class FileStorageService {
  private ossClient: OSS;
  private cdnDomain: string;
  
  constructor(config: {
    region: string;
    accessKeyId: string;
    accessKeySecret: string;
    bucket: string;
    cdnDomain?: string;
  }) {
    this.ossClient = new OSS({
      region: config.region,
      accessKeyId: config.accessKeyId,
      accessKeySecret: config.accessKeySecret,
      bucket: config.bucket,
    });
    this.cdnDomain = config.cdnDomain || '';
  }
  
  /**
   * 上传文件
   */
  async upload(
    file: Buffer | Express.Multer.File,
    options: UploadOptions
  ): Promise<UploadResult> {
    const buffer = file instanceof Buffer ? file : file.buffer;
    const mimeType = file instanceof Buffer ? this.detectMimeType(buffer) : file.mimetype;
    
    // 验证文件
    this.validateFile(buffer, mimeType, options);
    
    // 生成存储路径
    const fileId = uuidv4();
    const now = new Date();
    const key = this.generateKey(options, fileId, now, mimeType);
    
    // 上传到OSS
    const result = await this.ossClient.put(key, buffer, {
      headers: {
        'Content-Type': mimeType,
        'x-oss-object-acl': 'private',
      }
    });
    
    // 生成缩略图
    let thumbnailUrl: string | undefined;
    if (options.generateThumbnail && this.isImage(mimeType)) {
      thumbnailUrl = await this.generateThumbnail(buffer, key);
    }
    
    return {
      key,
      url: this.getPublicUrl(key),
      thumbnailUrl,
      size: buffer.length,
      mimeType,
      etag: result.etag,
    };
  }
  
  /**
   * 生成存储路径
   */
  private generateKey(
    options: UploadOptions,
    fileId: string,
    date: Date,
    mimeType: string
  ): string {
    const ext = this.getExtension(mimeType);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    
    switch (options.fileType) {
      case 'note':
        return `notes/${options.userId}/${year}/${month}/${fileId}/original${ext}`;
      case 'mistake':
        return `mistakes/${options.userId}/${year}/${month}/${fileId}${ext}`;
      case 'avatar':
        return `avatars/${options.userId}${ext}`;
      case 'attachment':
        return `attachments/${options.userId}/${year}/${month}/${fileId}${ext}`;
      default:
        throw new Error(`Unknown file type: ${options.fileType}`);
    }
  }
  
  /**
   * 生成缩略图
   */
  private async generateThumbnail(
    buffer: Buffer,
    originalKey: string
  ): Promise<string> {
    const thumbnailKey = originalKey.replace('/original', '/thumbnails');
    
    const thumbnailBuffer = await sharp(buffer)
      .resize(300, 300, { fit: 'inside' })
      .jpeg({ quality: 80 })
      .toBuffer();
    
    await this.ossClient.put(thumbnailKey, thumbnailBuffer);
    
    return this.getPublicUrl(thumbnailKey);
  }
  
  /**
   * 获取公开URL (带签名)
   */
  getSignedUrl(key: string, expiresInSeconds: number = 3600): string {
    return this.ossClient.signatureUrl(key, {
      expires: expiresInSeconds,
      method: 'GET',
    });
  }
  
  /**
   * 获取CDN加速URL
   */
  private getPublicUrl(key: string): string {
    if (this.cdnDomain) {
      return `https://${this.cdnDomain}/${key}`;
    }
    return `https://${this.ossClient.options.bucket}.${this.ossClient.options.region}.aliyuncs.com/${key}`;
  }
  
  /**
   * 删除文件
   */
  async delete(key: string): Promise<void> {
    await this.ossClient.delete(key);
    
    // 同时删除缩略图
    const thumbnailKey = key.replace('/original', '/thumbnails');
    try {
      await this.ossClient.delete(thumbnailKey);
    } catch {
      // 缩略图可能不存在
    }
  }
  
  /**
   * 批量删除
   */
  async deleteMultiple(keys: string[]): Promise<void> {
    await this.ossClient.deleteMulti(keys);
  }
  
  /**
   * 验证文件
   */
  private validateFile(
    buffer: Buffer,
    mimeType: string,
    options: UploadOptions
  ): void {
    // 检查大小
    const maxSize = options.maxSize || 10 * 1024 * 1024; // 默认10MB
    if (buffer.length > maxSize) {
      throw new Error(`File size exceeds limit: ${maxSize} bytes`);
    }
    
    // 检查MIME类型
    const allowedMimes = options.allowedMimes || [
      'image/jpeg',
      'image/png',
      'image/webp',
      'application/pdf',
    ];
    
    if (!allowedMimes.includes(mimeType)) {
      throw new Error(`File type not allowed: ${mimeType}`);
    }
    
    // 病毒扫描 (可选，集成ClamAV)
  }
  
  private isImage(mimeType: string): boolean {
    return mimeType.startsWith('image/');
  }
  
  private detectMimeType(buffer: Buffer): string {
    // 使用file-type库检测
    return 'application/octet-stream';
  }
  
  private getExtension(mimeType: string): string {
    const extensions: Record<string, string> = {
      'image/jpeg': '.jpg',
      'image/png': '.png',
      'image/webp': '.webp',
      'application/pdf': '.pdf',
    };
    return extensions[mimeType] || '';
  }
}
```

### 5.3 文件存储策略对比

| 存储方案 | 优势 | 劣势 | 成本 (按量) | 推荐场景 |
|---------|------|------|------------|---------|
| **阿里云OSS** | • 国内速度快<br>• 稳定可靠<br>• 丰富功能 | • 区域限制 | ¥0.12/GB/月<br>¥0.5/GB流量 | 国内用户为主 |
| **AWS S3** | • 全球覆盖<br>• 生态完善 | • 国内速度慢<br>• 支付复杂 | $0.023/GB/月 | 国际用户 |
| **自建MinIO** | • 完全控制<br>• 无额外费用 | • 运维成本高<br>• 扩展复杂 | 服务器成本 | 数据敏感/内网 |
| **混合方案** | • 灵活性高 | • 架构复杂 | - | 大型企业 |

**推荐**: 阿里云OSS + CDN加速

---

## 六、实时协作方案

### 6.1 协作架构设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          实时协作架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  客户端 A                        服务端                        客户端 B      │
│     │                            │                             │           │
│     │  1. 连接WebSocket           │                             │           │
│     ├────────────────────────────►│                             │           │
│     │                            │  2. 认证 + 房间分配            │           │
│     │                            ├────────────────────────────►│           │
│     │                            │                             │           │
│     │  3. 编辑笔记 (操作转换)     │                             │           │
│     ├────────────────────────────►│                             │           │
│     │                            │  4. 广播操作                  │           │
│     │                            ├────────────────────────────►│           │
│     │                            │  5. 持久化到数据库            │           │
│     │                            ├────────────────────────────►│           │
│     │                            │                             │           │
│     │  6. 接收B的操作             │                             │           │
│     │◄────────────────────────────┤  7. B的编辑                  │           │
│     │                            │◄────────────────────────────┤           │
│     │  8. OT/CRTP合并冲突         │                             │           │
│     │                            │                             │           │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    协作服务核心组件                                   │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │   │
│  │  │ WebSocket   │  │ 房间管理     │  │ 操作转换     │  │ 冲突解决     │  │   │
│  │  │ 网关         │  │ (Room)      │  │ (OT/CRTP)   │  │ (Resolver)  │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 WebSocket 服务实现

```typescript
// services/collaboration/websocket.service.ts
import { WebSocketServer, WebSocket } from 'ws';
import { v4 as uuidv4 } from 'uuid';
import { Redis } from 'ioredis';

interface CollaborationRoom {
  id: string;
  resourceId: string;
  resourceType: 'note' | 'mindmap';
  participants: Map<string, WebSocket>;
  documentState: any;
  operations: Operation[];
}

interface Operation {
  id: string;
  userId: string;
  type: 'insert' | 'delete' | 'retain' | 'format';
  position: number;
  length?: number;
  content?: string;
  attributes?: any;
  timestamp: number;
}

export class CollaborationService {
  private wss: WebSocketServer;
  private rooms: Map<string, CollaborationRoom>;
  private redis: Redis;
  private pubClient: Redis;
  private subClient: Redis;
  
  constructor(port: number, redisConfig: any) {
    this.wss = new WebSocketServer({ port });
    this.rooms = new Map();
    this.redis = new Redis(redisConfig);
    this.pubClient = new Redis(redisConfig);
    this.subClient = new Redis(redisConfig);
    
    this.setupRedisPubSub();
    this.setupWebSocketServer();
  }
  
  private setupRedisPubSub(): void {
    this.subClient.subscribe('collaboration:operations');
    
    this.subClient.on('message', (channel, message) => {
      if (channel === 'collaboration:operations') {
        const operation = JSON.parse(message);
        this.broadcastToRoom(operation.roomId, operation, operation.senderId);
      }
    });
  }
  
  private setupWebSocketServer(): void {
    this.wss.on('connection', (ws: WebSocket, req) => {
      const userId = this.extractUserId(req);
      const roomId = this.extractRoomId(req);
      
      if (!userId || !roomId) {
        ws.close(4001, 'Unauthorized');
        return;
      }
      
      this.handleConnection(ws, userId, roomId);
    });
  }
  
  private async handleConnection(
    ws: WebSocket,
    userId: string,
    roomId: string
  ): Promise<void> {
    // 获取或创建房间
    let room = this.rooms.get(roomId);
    if (!room) {
      room = await this.createRoom(roomId);
    }
    
    // 添加参与者
    room.participants.set(userId, ws);
    
    // 发送当前文档状态
    ws.send(JSON.stringify({
      type: 'init',
      documentState: room.documentState,
      participants: Array.from(room.participants.keys()),
    }));
    
    // 广播新用户加入
    this.broadcastToRoom(roomId, {
      type: 'user_joined',
      userId,
    });
    
    // 处理消息
    ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString());
        await this.handleMessage(room, userId, message);
      } catch (error) {
        ws.send(JSON.stringify({
          type: 'error',
          message: error.message,
        }));
      }
    });
    
    // 处理断开
    ws.on('close', () => {
      this.handleDisconnection(room, userId);
    });
  }
  
  private async handleMessage(
    room: CollaborationRoom,
    userId: string,
    message: any
  ): Promise<void> {
    switch (message.type) {
      case 'operation':
        await this.handleOperation(room, userId, message);
        break;
        
      case 'cursor':
        this.broadcastToRoom(room.id, {
          type: 'cursor_update',
          userId,
          position: message.position,
        });
        break;
        
      case 'selection':
        this.broadcastToRoom(room.id, {
          type: 'selection_update',
          userId,
          selection: message.selection,
        });
        break;
    }
  }
  
  private async handleOperation(
    room: CollaborationRoom,
    userId: string,
    message: any
  ): Promise<void> {
    const operation: Operation = {
      id: uuidv4(),
      userId,
      type: message.op.type,
      position: message.op.position,
      length: message.op.length,
      content: message.op.content,
      attributes: message.op.attributes,
      timestamp: Date.now(),
    };
    
    // 操作转换 (OT)
    const transformedOp = this.transformOperation(room, operation);
    
    // 应用到文档状态
    this.applyOperation(room, transformedOp);
    
    // 保存操作历史
    room.operations.push(transformedOp);
    
    // 广播操作
    this.broadcastToRoom(room.id, {
      type: 'operation',
      operation: transformedOp,
      senderId: userId,
    });
    
    // 持久化到数据库 (异步)
    this.persistDocument(room.id);
  }
  
  private transformOperation(
    room: CollaborationRoom,
    operation: Operation
  ): Operation {
    // 实现操作转换算法
    // 这里简化实现，实际需要完整的OT/CRTP算法
    const concurrentOps = room.operations.filter(
      op => op.timestamp > operation.timestamp - 1000
    );
    
    let transformedOp = { ...operation };
    
    for (const concurrentOp of concurrentOps) {
      transformedOp = this.transform(transformedOp, concurrentOp);
    }
    
    return transformedOp;
  }
  
  private transform(op1: Operation, op2: Operation): Operation {
    // 简化的转换逻辑
    // 实际需要根据OT算法实现
    if (op1.type === 'insert' && op2.type === 'insert') {
      if (op1.position <= op2.position) {
        return op1;
      }
      return {
        ...op1,
        position: op1.position + (op2.content?.length || 0),
      };
    }
    return op1;
  }
  
  private applyOperation(room: CollaborationRoom, operation: Operation): void {
    // 应用操作到文档状态
    // 这里需要根据具体的文档格式实现
  }
  
  private async persistDocument(roomId: string): Promise<void> {
    // 从Redis获取最新状态并持久化到PostgreSQL
    const state = await this.redis.get(`doc:${roomId}`);
    if (state) {
      // 保存到数据库
    }
  }
  
  private broadcastToRoom(
    roomId: string,
    message: any,
    excludeUserId?: string
  ): void {
    const room = this.rooms.get(roomId);
    if (!room) return;
    
    const data = JSON.stringify(message);
    
    room.participants.forEach((ws, userId) => {
      if (userId !== excludeUserId && ws.readyState === WebSocket.OPEN) {
        ws.send(data);
      }
    });
    
    // 跨实例广播 (通过Redis)
    this.pubClient.publish('collaboration:operations', JSON.stringify({
      ...message,
      roomId,
    }));
  }
  
  private handleDisconnection(room: CollaborationRoom, userId: string): void {
    room.participants.delete(userId);
    
    this.broadcastToRoom(room.id, {
      type: 'user_left',
      userId,
    });
    
    // 清理空房间
    if (room.participants.size === 0) {
      this.rooms.delete(room.id);
    }
  }
  
  private async createRoom(roomId: string): Promise<CollaborationRoom> {
    // 从数据库加载文档状态
    const documentState = await this.loadDocumentState(roomId);
    
    const room: CollaborationRoom = {
      id: roomId,
      resourceId: roomId,
      resourceType: 'note',
      participants: new Map(),
      documentState,
      operations: [],
    };
    
    this.rooms.set(roomId, room);
    return room;
  }
  
  private async loadDocumentState(roomId: string): Promise<any> {
    // 从数据库加载
    return {};
  }
  
  private extractUserId(req: any): string | null {
    // 从认证token提取用户ID
    return null;
  }
  
  private extractRoomId(req: any): string | null {
    // 从URL提取房间ID
    return null;
  }
}
```

### 6.3 冲突解决策略

| 场景 | 解决策略 | 实现方式 |
|------|---------|---------|
| **同时编辑同一段落** | 操作转换(OT) | 保留所有操作，调整位置 |
| **格式冲突** | 后写入优先 | 使用最新格式 |
| **删除冲突** | 保留删除 | 删除操作优先 |
| **离线编辑后同步** | CRDT | 自动合并 |
| **脑图结构冲突** | 用户选择 | 弹出对话框让用户选择 |

---

## 七、可扩展性设计

### 7.1 分层扩展策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        可扩展性演进路线                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Phase 1: 单体应用 (0-10K 用户)                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  [单服务器]                                                         │   │
│  │  ┌─────────────────────────────────────────────────────────────┐    │   │
│  │  │  Next.js + NestJS + PostgreSQL + Redis                      │    │   │
│  │  └─────────────────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  Phase 2: 负载均衡 (10K-50K 用户)                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  [负载均衡]                                                         │   │
│  │        │                                                            │   │
│  │   ┌────┴────┬────────┐                                               │   │
│  │   ▼         ▼        ▼                                               │   │
│  │ [Web1]   [Web2]   [Web3]                                            │   │
│  │   │         │        │                                               │   │
│  │   └─────────┼────────┘                                               │   │
│  │             ▼                                                        │   │
│  │  [PostgreSQL 主] ← [PostgreSQL 从]                                   │   │
│  │  [Redis 集群]                                                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  Phase 3: 服务分离 (50K-200K 用户)                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  [CDN]                                                              │   │
│  │   │                                                                 │   │
│  │  [API网关] → [认证服务] [笔记服务] [AI服务] [协作服务]               │   │
│  │                  │          │         │         │                  │   │
│  │                  └──────────┼─────────┼─────────┘                  │   │
│  │                             ▼         ▼                            │   │
│  │                    [PostgreSQL集群] [Redis集群] [向量DB]            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  Phase 4: 微服务架构 (200K+ 用户)                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  [服务网格]                                                        │   │
│  │   │                                                                 │   │
│  │   ├── [用户服务] × 3                                                 │   │
│  │   ├── [笔记服务] × 5                                                 │   │
│  │   ├── [AI服务] × 10                                                  │   │
│  │   ├── [实时服务] × 3                                                 │   │
│  │   └── [分析服务] × 2                                                 │   │
│  │                                                                      │   │
│  │  [分片数据库] [缓存集群] [消息队列] [向量数据库集群]                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 7.2 数据库扩展方案

#### 读写分离

```typescript
// services/database/dataSource.ts
import { DataSource, DataSourceOptions } from 'typeorm';

export class AppDataSource {
  private static master: DataSource;
  private static slaves: DataSource[] = [];
  
  static async initialize(config: {
    master: DataSourceOptions;
    slaves: DataSourceOptions[];
  }): Promise<void> {
    // 主库
    this.master = new DataSource({
      ...config.master,
      type: 'postgres',
      synchronize: false,
      logging: false,
    });
    await this.master.initialize();
    
    // 从库
    this.slaves = await Promise.all(
      config.slaves.map(options => {
        const slave = new DataSource({
          ...options,
          type: 'postgres',
          synchronize: false,
          logging: false,
        });
        return slave.initialize();
      })
    );
  }
  
  static getMaster(): DataSource {
    return this.master;
  }
  
  static getSlave(): DataSource {
    if (this.slaves.length === 0) {
      return this.master;
    }
    // 随机选择一个从库
    const index = Math.floor(Math.random() * this.slaves.length);
    return this.slaves[index];
  }
  
  static getQueryRunner() {
    return {
      master: () => this.master.createQueryRunner(),
      slave: () => this.getSlave().createQueryRunner(),
    };
  }
}

// Repository 基类
export class BaseRepository<T> {
  async findOne(id: string): Promise<T | null> {
    const queryRunner = AppDataSource.getQueryRunner().slave();
    // 使用从库查询
  }
  
  async save(entity: T): Promise<T> {
    const queryRunner = AppDataSource.getQueryRunner().master();
    // 使用主库写入
  }
}
```

#### 数据分片策略

```typescript
// services/database/sharding.service.ts
export class ShardingService {
  private shardCount: number;
  
  constructor(shardCount: number = 16) {
    this.shardCount = shardCount;
  }
  
  /**
   * 根据用户ID计算分片
   */
  getShardByUser(userId: string): number {
    const hash = this.hash(userId);
    return hash % this.shardCount;
  }
  
  /**
   * 根据笔记ID计算分片
   */
  getShardByNote(noteId: string): number {
    const hash = this.hash(noteId);
    return hash % this.shardCount;
  }
  
  /**
   * 获取分片表名
   */
  getShardedTableName(baseName: string, shard: number): string {
    return `${baseName}_shard_${shard}`;
  }
  
  private hash(value: string): number {
    let hash = 0;
    for (let i = 0; i < value.length; i++) {
      const char = value.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash);
  }
}

// 使用示例
const sharding = new ShardingService(16);

// 查询用户笔记
const shard = sharding.getShardByUser(userId);
const tableName = sharding.getShardedTableName('notes', shard);
const query = `SELECT * FROM ${tableName} WHERE user_id = $1`;
```

### 7.3 缓存策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          多层缓存架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        L1: 浏览器缓存                               │   │
│  │  • 静态资源 (1天)   • API响应 (1分钟)   • 用户设置 (1小时)          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        L2: CDN缓存                                  │   │
│  │  • 图片/视频 (7天)   • CSS/JS (30天)   • 公开笔记 (1小时)           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        L3: 应用层缓存 (本地)                         │   │
│  │  • Node-cache (内存)   • 热点数据 (5分钟)   • 用户会话               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        L4: Redis缓存                                 │   │
│  │  • 用户信息 (1小时)   • 笔记列表 (10分钟)   • AI响应 (24小时)        │   │
│  │  • 计数器 (实时)      • 分布式锁   • 限流                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        L5: 数据库                                    │   │
│  │  • 查询缓存   • 连接池   • 索引优化                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 八、安全性设计

### 8.1 安全架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          安全防护体系                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        网络层安全                                   │   │
│  │  • WAF防火墙   • DDoS防护   • IP白名单   • TLS/SSL加密              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        应用层安全                                   │   │
│  │  • 认证授权 (JWT + OAuth)   • RBAC权限控制   • API签名             │   │
│  │  • 输入验证 (Zod)   • SQL注入防护   • XSS防护                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        数据层安全                                   │   │
│  │  • 字段加密 (敏感数据)   • 传输加密   • 备份加密                    │   │
│  │  • 数据脱敏 (日志)   • 最小权限原则                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        业务层安全                                   │   │
│  │  • 内容审核 (敏感词)   • 文件病毒扫描   • 频率限制                  │   │
│  │  • 异常检测   • 审计日志   • 安全告警                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.2 认证授权实现

```typescript
// services/auth/auth.service.ts
import { sign, verify } from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import { v4 as uuidv4 } from 'uuid';

export interface TokenPayload {
  userId: string;
  username: string;
  tier: string;
}

export class AuthService {
  private jwtSecret: string;
  private refreshTokenSecret: string;
  
  constructor() {
    this.jwtSecret = process.env.JWT_SECRET!;
    this.refreshTokenSecret = process.env.REFRESH_TOKEN_SECRET!;
  }
  
  /**
   * 用户登录
   */
  async login(email: string, password: string): Promise<{
    accessToken: string;
    refreshToken: string;
    user: any;
  }> {
    // 查询用户
    const user = await this.userRepository.findByEmail(email);
    if (!user) {
      throw new Error('Invalid credentials');
    }
    
    // 验证密码
    const isValid = await bcrypt.compare(password, user.password_hash);
    if (!isValid) {
      throw new Error('Invalid credentials');
    }
    
    // 检查账户状态
    if (user.status !== 'active') {
      throw new Error('Account is not active');
    }
    
    // 生成Token
    const payload: TokenPayload = {
      userId: user.id,
      username: user.username,
      tier: user.subscription_tier,
    };
    
    const accessToken = this.generateAccessToken(payload);
    const refreshToken = this.generateRefreshToken(payload);
    
    // 保存refresh token
    await this.saveRefreshToken(user.id, refreshToken);
    
    // 更新最后登录时间
    await this.userRepository.updateLastLogin(user.id);
    
    return {
      accessToken,
      refreshToken,
      user: this.sanitizeUser(user),
    };
  }
  
  /**
   * 生成访问令牌
   */
  private generateAccessToken(payload: TokenPayload): string {
    return sign(payload, this.jwtSecret, {
      expiresIn: '15m',
      issuer: 'study-notes',
      audience: 'study-notes-api',
      jwtid: uuidv4(),
    });
  }
  
  /**
   * 生成刷新令牌
   */
  private generateRefreshToken(payload: TokenPayload): string {
    return sign(
      { userId: payload.userId },
      this.refreshTokenSecret,
      { expiresIn: '30d' }
    );
  }
  
  /**
   * 验证访问令牌
   */
  verifyAccessToken(token: string): TokenPayload {
    try {
      return verify(token, this.jwtSecret) as TokenPayload;
    } catch (error) {
      throw new Error('Invalid token');
    }
  }
  
  /**
   * 刷新令牌
   */
  async refreshTokens(refreshToken: string): Promise<{
    accessToken: string;
    refreshToken: string;
  }> {
    const payload = verify(refreshToken, this.refreshTokenSecret) as { userId: string };
    
    // 检查refresh token是否有效
    const storedToken = await this.getRefreshToken(payload.userId);
    if (storedToken !== refreshToken) {
      throw new Error('Invalid refresh token');
    }
    
    // 获取用户信息
    const user = await this.userRepository.findById(payload.userId);
    if (!user) {
      throw new Error('User not found');
    }
    
    // 生成新Token
    const tokenPayload: TokenPayload = {
      userId: user.id,
      username: user.username,
      tier: user.subscription_tier,
    };
    
    return {
      accessToken: this.generateAccessToken(tokenPayload),
      refreshToken: this.generateRefreshToken(tokenPayload),
    };
  }
  
  /**
   * 登出
   */
  async logout(userId: string): Promise<void> {
    await this.deleteRefreshToken(userId);
  }
  
  private sanitizeUser(user: any): any {
    const { password_hash, ...sanitized } = user;
    return sanitized;
  }
}

// 权限守卫
export class RolesGuard {
  constructor(private requiredRoles: string[]) {}
  
  canActivate(context: any): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    
    if (!user) {
      return false;
    }
    
    return this.requiredRoles.includes(user.role);
  }
}

// 资源所有权检查
export class OwnershipGuard {
  async canActivate(context: any): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const resourceId = request.params.id;
    
    // 检查资源是否属于用户
    const resource = await this.resourceRepository.findById(resourceId);
    return resource?.user_id === user.userId;
  }
}
```

### 8.3 内容安全审核

```typescript
// services/security/contentModeration.service.ts
export class ContentModerationService {
  private sensitiveWords: Set<string>;
  private regexPatterns: RegExp[];
  
  constructor() {
    this.sensitiveWords = new Set();
    this.regexPatterns = [];
    this.loadSensitiveWords();
  }
  
  /**
   * 检查文本内容
   */
  async checkText(text: string): Promise<{
    safe: boolean;
    issues: string[];
    masked?: string;
  }> {
    const issues: string[] = [];
    let maskedText = text;
    
    // 检查敏感词
    const foundWords = this.findSensitiveWords(text);
    if (foundWords.length > 0) {
      issues.push(`Contains sensitive words: ${foundWords.join(', ')}`);
      maskedText = this.maskSensitiveWords(text);
    }
    
    // 检查违规模式
    const patternMatches = this.checkPatterns(text);
    if (patternMatches.length > 0) {
      issues.push(`Contains prohibited patterns: ${patternMatches.join(', ')}`);
    }
    
    // 检查垃圾内容
    if (this.isSpam(text)) {
      issues.push('Content appears to be spam');
    }
    
    return {
      safe: issues.length === 0,
      issues,
      masked: maskedText,
    };
  }
  
  /**
   * 检查图片
   */
  async checkImage(imageBuffer: Buffer): Promise<{
    safe: boolean;
    issues: string[];
  }> {
    const issues: string[] = [];
    
    // 调用阿里云内容安全API
    try {
      const result = await this.callGreenImageScan(imageBuffer);
      if (!result.safe) {
        issues.push(...result.reasons);
      }
    } catch (error) {
      console.error('Image moderation failed:', error);
    }
    
    return {
      safe: issues.length === 0,
      issues,
    };
  }
  
  private findSensitiveWords(text: string): string[] {
    const found: string[] = [];
    const lowerText = text.toLowerCase();
    
    for (const word of this.sensitiveWords) {
      if (lowerText.includes(word)) {
        found.push(word);
      }
    }
    
    return found;
  }
  
  private maskSensitiveWords(text: string): string {
    let masked = text;
    for (const word of this.sensitiveWords) {
      const regex = new RegExp(word, 'gi');
      masked = masked.replace(regex, '*'.repeat(word.length));
    }
    return masked;
  }
  
  private checkPatterns(text: string): string[] {
    const matches: string[] = [];
    for (const pattern of this.regexPatterns) {
      if (pattern.test(text)) {
        matches.push(pattern.source);
      }
    }
    return matches;
  }
  
  private isSpam(text: string): boolean {
    // 简单的垃圾内容检测
    const spamIndicators = [
      /{email}/i,
      /{phone}/i,
      /{wechat}/i,
      /{qq}/i,
    ];
    
    return spamIndicators.some(pattern => pattern.test(text));
  }
  
  private async callGreenImageScan(imageBuffer: Buffer): Promise<{
    safe: boolean;
    reasons: string[];
  }> {
    // 调用阿里云内容安全API
    return { safe: true, reasons: [] };
  }
  
  private loadSensitiveWords(): void {
    // 从数据库或文件加载敏感词库
    this.sensitiveWords = new Set([
      // 敏感词列表
    ]);
  }
}
```

---

## 九、部署架构

### 9.1 部署架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          生产环境部署架构                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        DNS + CDN                                    │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                 │   │
│  │  │ 阿里云DNS    │  │ Cloudflare  │  │ 阿里云CDN   │                 │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌────────────────────────────────▼─────────────────────────────────────┐   │
│  │                        负载均衡 (SLB)                                │   │
│  │  • HTTPS卸载   • 健康检查   • 会话保持   • 证书管理                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌────────────────────────────────▼─────────────────────────────────────┐   │
│  │                        WAF防火墙                                     │   │
│  │  • SQL注入防护   • XSS防护   • CC攻击防护   • BOT防护                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌────────────────┬────────────────┼────────────────┬────────────────┐     │
│  │                │                │                │                │     │
│  ▼                ▼                ▼                ▼                │     │
│ ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐             │     │
│ │ Web Node │   │ Web Node │   │ Web Node │   │ Web Node │             │     │
│ │  Pod 1   │   │  Pod 2   │   │  Pod 3   │   │  Pod 4   │             │     │
│ │          │   │          │   │          │   │          │             │     │
│ │ Next.js  │   │ Next.js  │   │ Next.js  │   │ Next.js  │             │     │
│ └──────────┘   └──────────┘   └──────────┘   └──────────┘             │     │
│                                                                      │     │
│ ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐             │     │
│ │ API Pod  │   │ API Pod  │   │ API Pod  │   │ API Pod  │             │     │
│ │   1      │   │   2      │   │   3      │   │   4      │             │     │
│ │          │   │          │   │          │   │          │             │     │
│ │ NestJS   │   │ NestJS   │   │ NestJS   │   │ NestJS   │             │     │
│ └──────────┘   └──────────┘   └──────────┘   └──────────┘             │     │
│                                                                      │     │
│ ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐             │     │
│ │ AI Pod   │   │ AI Pod   │   │ AI Pod   │   │ AI Pod   │             │     │
│ │   1      │   │   2      │   │   3      │   │   4      │             │     │
│ │          │   │          │   │          │   │          │             │     │
│ │ FastAPI  │   │ FastAPI  │   │ FastAPI  │   │ FastAPI  │             │     │
│ └──────────┘   └──────────┘   └──────────┘   └──────────┘             │     │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        服务层 (托管)                                 │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                 │   │
│  │  │ PostgreSQL  │  │ Redis       │  │ RabbitMQ    │                 │   │
│  │  │ RDS (主从)  │  │ (集群模式)   │  │ (集群模式)   │                 │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                 │   │
│  │  ┌─────────────┐  ┌─────────────┐                                 │   │
│  │  │ 阿里云OSS    │  │ WebSocket   │                                 │   │
│  │  │ (对象存储)   │  │ (独立服务)   │                                 │   │
│  │  └─────────────┘  └─────────────┘                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        监控与日志                                     │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                 │   │
│  │  │ Prometheus  │  │ Grafana     │  │ ELK Stack   │                 │   │
│  │  │ (指标采集)   │  │ (可视化)    │  │ (日志分析)   │                 │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.2 Docker Compose 配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  # 前端服务
  web:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - API_URL=http://api:8000
    depends_on:
      - api
    restart: unless-stopped

  # API服务
  api:
    build:
      context: ./backend/api
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:pass@postgres:5432/study_notes
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
      - AI_SERVICE_URL=http://ai-service:8001
    depends_on:
      - postgres
      - redis
      - ai-service
    restart: unless-stopped

  # AI服务
  ai-service:
    build:
      context: ./backend/ai-service
      dockerfile: Dockerfile
    ports:
      - "8001:8001"
    environment:
      - DEEPSEEK_API_KEY=${DEEPSEEK_API_KEY}
      - QWEN_API_KEY=${QWEN_API_KEY}
      - BAIDU_OCR_API_KEY=${BAIDU_OCR_API_KEY}
      - REDIS_URL=redis://redis:6379
      - DATABASE_URL=postgresql://user:pass@postgres:5432/study_notes
    depends_on:
      - postgres
      - redis
    restart: unless-stopped
    # GPU支持 (如果需要)
    # deploy:
    #   resources:
    #     reservations:
    #       devices:
    #         - driver: nvidia
    #           count: 1
    #           capabilities: [gpu]

  # WebSocket服务
  websocket:
    build:
      context: ./backend/websocket
      dockerfile: Dockerfile
    ports:
      - "8002:8002"
    environment:
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - redis
    restart: unless-stopped

  # PostgreSQL
  postgres:
    image: pgvector/pgvector:pg16
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=study_notes
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    restart: unless-stopped

  # RabbitMQ
  rabbitmq:
    image: rabbitmq:3-management-alpine
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD}
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  rabbitmq_data:
```

### 9.3 Kubernetes 部署配置

```yaml
# k8s/deployment.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: study-notes

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
  namespace: study-notes
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
      - name: api
        image: registry.example.com/study-notes/api:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: api
  namespace: study-notes
spec:
  selector:
    app: api
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
  type: ClusterIP

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-hpa
  namespace: study-notes
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

---

## 十、总结与实施建议

### 10.1 架构决策汇总 (ADRs)

| ADR | 决策 | 状态 |
|-----|------|------|
| ADR-001 | 后端技术栈: Node.js(NestJS) + Python(FastAPI) | Accepted |
| ADR-002 | 数据库: PostgreSQL + pgvector | Accepted |
| ADR-003 | AI成本控制: 多层缓存 + 模型分级 | Accepted |

### 10.2 实施路径

#### 第一阶段 (MVP - 3个月)

```
┌─────────────────────────────────────────────────────────────────────┐
│                        MVP 实施计划                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Month 1: 基础设施搭建                                                │
│  • Week 1-2: 项目初始化、开发环境配置                                  │
│  • Week 3: 数据库设计与迁移脚本                                        │
│  • Week 4: 基础API框架搭建 (用户认证)                                  │
│                                                                      │
│  Month 2: 核心功能开发                                                │
│  • Week 5-6: 笔记CRUD + 文件上传                                      │
│  • Week 7: OCR集成                                                   │
│  • Week 8: AI脑图生成 (DeepSeek)                                     │
│                                                                      │
│  Month 3: 差异化功能                                                  │
│  • Week 9-10: 知识点提问 + 错题管理                                   │
│  • Week 11: 薄弱点分析                                               │
│  • Week 12: 测试 + 部署                                              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 第二阶段 (增强功能 - 3-6个月)

- 教材脑图对比
- 笔记智能合并
- 实时协作编辑
- 学习数据分析
- 移动端应用

#### 第三阶段 (规模化 - 6-12个月)

- 微服务拆分
- 读写分离
- CDN加速
- 多地域部署

### 10.3 技术债务管理

| 类别 | 项目 | 优先级 | 计划时间 |
|------|------|--------|---------|
| 安全 | 密码加密升级到bcrypt | HIGH | 立即 |
| 性能 | 添加Redis缓存层 | HIGH | Month 2 |
| 可维护性 | 补充单元测试 | MEDIUM | Month 3 |
| 扩展性 | 实现数据库读写分离 | MEDIUM | Month 6 |
| 安全 | 实现API签名验证 | MEDIUM | Month 4 |

### 10.4 监控指标

| 指标类型 | 具体指标 | 目标值 | 告警阈值 |
|---------|---------|--------|---------|
| 性能 | API响应时间 (P95) | < 200ms | > 500ms |
| 性能 | API响应时间 (P99) | < 500ms | > 1s |
| 可用性 | 服务 uptime | > 99.9% | < 99.5% |
| 成本 | AI API成本/用户 | < ¥2/月 | > ¥5/月 |
| 业务 | 用户留存率 (D7) | > 20% | < 15% |

---

本架构设计文档为"学习记录管理项目"提供了完整的技术架构方案。建议在实施过程中：

1. **先做减法**: MVP阶段只实现核心功能，验证产品价值
2. **逐步迭代**: 根据用户反馈和数据决定下一步开发方向
3. **关注成本**: AI服务成本需要严格控制，通过缓存和配额管理
4. **数据驱动**: 建立完善的监控和分析系统，支持产品决策

相关文档路径：
- **D:\work\StudyNotesManager\记录学习过程项目.md** - 功能需求文档
- **D:\work\StudyNotesManager\学习记录项目市场前景分析.md** - 市场分析文档
agentId: a5a093c (for resuming to continue this agent's work if needed)
<usage>total_tokens: 44369
tool_uses: 3
duration_ms: 409370</usage>